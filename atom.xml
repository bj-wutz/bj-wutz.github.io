<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Wutz&#39;s Blog</title>
  
  
  <link href="https://bj-wutz.github.io/atom.xml" rel="self"/>
  
  <link href="https://bj-wutz.github.io/"/>
  <updated>2022-05-10T11:09:02.252Z</updated>
  <id>https://bj-wutz.github.io/</id>
  
  <author>
    <name>wutz</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【Java面试精选】【10期】Redis 面试常见问答</title>
    <link href="https://bj-wutz.github.io/2022/05/10/%E3%80%90Java%E9%9D%A2%E8%AF%95%E7%B2%BE%E9%80%89%E3%80%91%E3%80%9010%E6%9C%9F%E3%80%91Redis-%E9%9D%A2%E8%AF%95%E5%B8%B8%E8%A7%81%E9%97%AE%E7%AD%94/"/>
    <id>https://bj-wutz.github.io/2022/05/10/%E3%80%90Java%E9%9D%A2%E8%AF%95%E7%B2%BE%E9%80%89%E3%80%91%E3%80%9010%E6%9C%9F%E3%80%91Redis-%E9%9D%A2%E8%AF%95%E5%B8%B8%E8%A7%81%E9%97%AE%E7%AD%94/</id>
    <published>2022-05-10T02:54:34.000Z</published>
    <updated>2022-05-10T11:09:02.252Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-什么是缓存雪崩？怎么解决"><a href="#1-什么是缓存雪崩？怎么解决" class="headerlink" title="1. 什么是缓存雪崩？怎么解决?"></a><strong>1. 什么是缓存雪崩？怎么解决?</strong></h2><p><img src="/.%5C%E3%80%90Java%E9%9D%A2%E8%AF%95%E7%B2%BE%E9%80%89%E3%80%91%E3%80%9010%E6%9C%9F%E3%80%91Redis-%E9%9D%A2%E8%AF%95%E5%B8%B8%E8%A7%81%E9%97%AE%E7%AD%94%5C1.png"></p><p>通常，我们会使用缓存用于缓冲对 DB 的冲击，如果缓存宕机，所有请求将直接打在 DB，造成 DB 宕机——从而导致整个系统宕机。</p><p><strong>如何解决呢？</strong></p><p><img src="/.%5C%E3%80%90Java%E9%9D%A2%E8%AF%95%E7%B2%BE%E9%80%89%E3%80%91%E3%80%9010%E6%9C%9F%E3%80%91Redis-%E9%9D%A2%E8%AF%95%E5%B8%B8%E8%A7%81%E9%97%AE%E7%AD%94%5C2.png"></p><p><strong>2 种策略（同时使用）：</strong></p><ul><li>对缓存做高可用，防止缓存宕机</li><li>使用断路器，如果缓存宕机，为了防止系统全部宕机，限制部分流量进入 DB，保证部分可用，其余的请求返回断路器的默认值。</li></ul><h2 id="2-什么是缓存穿透？怎么解决？"><a href="#2-什么是缓存穿透？怎么解决？" class="headerlink" title="2. 什么是缓存穿透？怎么解决？"></a>2. <strong>什么是缓存穿透？怎么解决？</strong></h2><p><strong>解释 1：</strong>缓存查询一个没有的 key，同时数据库也没有，如果黑客大量的使用这种方式，那么就会导致 DB 宕机。</p><p><strong>解决方案：</strong>我们可以使用一个默认值来防止，例如，当访问一个不存在的 key，然后再去访问数据库，还是没有，那么就在缓存里放一个占位符，下次来的时候，检查这个占位符，如果发生时占位符，就不去数据库查询了，防止 DB 宕机。</p><p><strong>解释 2：</strong>大量请求查询一个刚刚失效的 key，导致 DB 压力倍增，可能导致宕机，但实际上，查询的都是相同的数据。</p><p><strong>解决方案：</strong>可以在这些请求代码加上双重检查锁。但是那个阶段的请求会变慢。不过总比 DB 宕机好。</p><h2 id="3-什么是缓存并发竞争？怎么解决？"><a href="#3-什么是缓存并发竞争？怎么解决？" class="headerlink" title="3. 什么是缓存并发竞争？怎么解决？"></a>3. <strong>什么是缓存并发竞争？怎么解决？</strong></h2><p><strong>解释：</strong>多个客户端写一个 key，如果顺序错了，数据就不对了。但是顺序我们无法控制。</p><p><strong>解决方案：</strong>使用分布式锁，例如 zk，同时加入数据的时间戳。同一时刻，只有抢到锁的客户端才能写入，同时，写入时，比较当前数据的时间戳和缓存中数据的时间戳。</p><h2 id="4-什么是缓存和数据库双写不一致？怎么解决？"><a href="#4-什么是缓存和数据库双写不一致？怎么解决？" class="headerlink" title="4. 什么是缓存和数据库双写不一致？怎么解决？"></a>4. <strong>什么是缓存和数据库双写不一致？怎么解决？</strong></h2><p><strong>解释：</strong>连续写数据库和缓存，但是操作期间，出现并发了，数据不一致了。</p><p>通常，更新缓存和数据库有以下几种顺序：</p><ul><li>先更新数据库，再更新缓存。</li><li>先删缓存，再更新数据库。</li><li>先更新数据库，再删除缓存。</li></ul><p>三种方式的优劣来看一下：</p><p><strong>先更新数据库，再更新缓存。</strong></p><p>这么做的问题是：当有 2 个请求同时更新数据，那么如果不使用分布式锁，将无法控制最后缓存的值到底是多少。也就是并发写的时候有问题。</p><p><strong>先删缓存，再更新数据库。</strong></p><p>这么做的问题：如果在删除缓存后，有客户端读数据，将可能读到旧数据，并有可能设置到缓存中，导致缓存中的数据一直是老数据。</p><p>有 2 种解决方案：</p><ul><li>使用“双删”，即删更删，最后一步的删除作为异步操作，就是防止有客户端读取的时候设置了旧值。</li><li>使用队列，当这个 key 不存在时，将其放入队列，串行执行，必须等到更新数据库完毕才能读取数据。</li></ul><p>总的来讲，比较麻烦。</p><p><strong>先更新数据库，再删除缓存</strong></p><p>这个实际是常用的方案，但是有很多人不知道，这里介绍一下，这个叫 Cache Aside Pattern，老外发明的。如果先更新数据库，再删除缓存，那么就会出现更新数据库之前有瞬间数据不是很及时。</p><p>同时，如果在更新之前，缓存刚好失效了，读客户端有可能读到旧值，然后在写客户端删除结束后再次设置了旧值，非常巧合的情况。</p><p>有 2 个前提条件：<strong>缓存在写之前的时候失效，同时，在写客户度删除操作结束后，放置旧数据 —— 也就是读比写慢。设置有的写操作还会锁表。</strong></p><p>所以，这个很难出现，但是如果出现了怎么办？使用双删！！！记录更新期间有没有客户端读数据库，如果有，在更新完数据库之后，执行延迟删除。</p><p>还有一种可能，如果执行更新数据库，准备执行删除缓存时，服务挂了，执行删除失败怎么办？？？</p><p>这就坑了！！！不过可以通过订阅数据库的 binlog 来删除。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-什么是缓存雪崩？怎么解决&quot;&gt;&lt;a href=&quot;#1-什么是缓存雪崩？怎么解决&quot; class=&quot;headerlink&quot; title=&quot;1. 什么是缓存雪崩？怎么解决?&quot;&gt;&lt;/a&gt;&lt;strong&gt;1. 什么是缓存雪崩？怎么解决?&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;&lt;</summary>
      
    
    
    
    <category term="Java面试精选" scheme="https://bj-wutz.github.io/categories/Java%E9%9D%A2%E8%AF%95%E7%B2%BE%E9%80%89/"/>
    
    
    <category term="Java" scheme="https://bj-wutz.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>【Java面试精选】【09期】说说hashCode() 和 equals() 之间的关系？</title>
    <link href="https://bj-wutz.github.io/2022/05/09/%E3%80%90Java%E9%9D%A2%E8%AF%95%E7%B2%BE%E9%80%89%E3%80%91%E3%80%9009%E6%9C%9F%E3%80%91%E8%AF%B4%E8%AF%B4hashCode-%E5%92%8C-equals-%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB%EF%BC%9F/"/>
    <id>https://bj-wutz.github.io/2022/05/09/%E3%80%90Java%E9%9D%A2%E8%AF%95%E7%B2%BE%E9%80%89%E3%80%91%E3%80%9009%E6%9C%9F%E3%80%91%E8%AF%B4%E8%AF%B4hashCode-%E5%92%8C-equals-%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB%EF%BC%9F/</id>
    <published>2022-05-09T02:54:34.000Z</published>
    <updated>2022-05-10T11:09:02.249Z</updated>
    
    <content type="html"><![CDATA[<h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a><strong>面试题</strong></h2><p>【强制】关于hashCode和equals的处理，遵循如下规则：</p><ul><li><p>只要重写equals，就必须重写hashCode。</p></li><li><p>因为Set存储的是不重复的对象，依据hashCode和equals进行判断，所以Set存储的对象必须重写这两个方法。</p></li><li><p>如果自定义对象作为Map的key，那么必须重写hashCode和equals。</p></li></ul><p><strong>说明：String重写了hashCode和equals方法，所以我们可以非常愉快的使用String对象作为key来使用。</strong></p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a><strong>介绍</strong></h2><p>equals() 的作用是用来判断两个对象是否相等。</p><p>hashCode() 的作用是获取哈希码，也称为散列码；它实际上是返回一个int整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。</p><h2 id="关系"><a href="#关系" class="headerlink" title="关系"></a><strong>关系</strong></h2><p>我们以“类的用途”来将“hashCode() 和 equals()的关系”分两种情况来说明。</p><h3 id="不会创建“类对应的散列表”"><a href="#不会创建“类对应的散列表”" class="headerlink" title="不会创建“类对应的散列表”"></a><strong>不会创建“类对应的散列表”</strong></h3><p>这里所说的“不会创建类对应的散列表”是说：我们不会在HashSet, Hashtable, HashMap等等这些本质是散列表的数据结构中，用到该类。例如，不会创建该类的HashSet集合。</p><p>在这种情况下，该类的“hashCode() 和 equals() ”没有半毛钱关系的！equals() 用来比较该类的两个对象是否相等。而hashCode() 则根本没有任何作用。</p><p>下面，我们通过示例查看类的两个对象相等以及不等时hashCode()的取值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.Comparable;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@desc</span> 比较equals() 返回true 以及 返回false时， hashCode()的值。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NormalHashCodeTest</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 新建2个相同内容的Person对象，</span></span><br><span class="line">        <span class="comment">// 再用equals比较它们是否相等</span></span><br><span class="line">        <span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;eee&quot;</span>, <span class="number">100</span>);</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;eee&quot;</span>, <span class="number">100</span>);</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;aaa&quot;</span>, <span class="number">200</span>);</span><br><span class="line">        System.out.printf(<span class="string">&quot;p1.equals(p2) : %s; p1(%d) p2(%d)\n&quot;</span>, p1.equals(p2), p1.hashCode(), p2.hashCode());</span><br><span class="line">        System.out.printf(<span class="string">&quot;p1.equals(p3) : %s; p1(%d) p3(%d)\n&quot;</span>, p1.equals(p3), p1.hashCode(), p3.hashCode());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@desc</span> Person类。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">        <span class="type">int</span> age;</span><br><span class="line">        String name;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.name = name;</span><br><span class="line">            <span class="built_in">this</span>.age = age;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> name + <span class="string">&quot; - &quot;</span> +age;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** </span></span><br><span class="line"><span class="comment">         * <span class="doctag">@desc</span> 覆盖equals方法 </span></span><br><span class="line"><span class="comment">         */</span>  </span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span>&#123;  </span><br><span class="line">            <span class="keyword">if</span>(obj == <span class="literal">null</span>)&#123;  </span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">            &#125;  </span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果是同一个对象返回true，反之返回false  </span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">this</span> == obj)&#123;  </span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="comment">//判断是否类型相同  </span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">this</span>.getClass() != obj.getClass())&#123;  </span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> (Person)obj;  </span><br><span class="line">            <span class="keyword">return</span> name.equals(person.name) &amp;&amp; age==person.age;  </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p1.equals(p2) : true; p1(1169863946) p2(1901116749)</span><br><span class="line">p1.equals(p3) : false; p1(1169863946) p3(2131949076)</span><br></pre></td></tr></table></figure><p>从结果也可以看出：p1和p2相等的情况下，hashCode()也不一定相等。</p><h3 id="会创建“类对应的散列表”"><a href="#会创建“类对应的散列表”" class="headerlink" title="会创建“类对应的散列表”"></a><strong>会创建“类对应的散列表”</strong></h3><p>这里所说的“会创建类对应的散列表”是说：我们会在HashSet, Hashtable, HashMap等等这些本质是散列表的数据结构中，用到该类。例如，会创建该类的HashSet集合。</p><p>在这种情况下，该类的“hashCode() 和 equals() ”是有关系的：</p><ul><li>如果两个对象相等，那么它们的hashCode()值一定相同。这里的相等是指，通过equals()比较两个对象时返回true。</li><li>如果两个对象hashCode()相等，它们并不一定相等。因为在散列表中，hashCode()相等，即两个键值对的哈希值相等。然而哈希值相等，并不一定能得出键值对相等。补充说一句：“两个不同的键值对，哈希值相等”，这就是哈希冲突。</li></ul><p>此外，在这种情况下。若要判断两个对象是否相等，除了要覆盖equals()之外，也要覆盖hashCode()函数。否则，equals()无效。</p><p>举例，创建Person类的HashSet集合，必须同时覆盖Person类的equals() 和 hashCode()方法。 </p><p>如果单单只是覆盖equals()方法。我们会发现，equals()方法没有达到我们想要的效果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.Comparable;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@desc</span> 比较equals() 返回true 以及 返回false时， hashCode()的值。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConflictHashCodeTest1</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 新建Person对象，</span></span><br><span class="line">        <span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;eee&quot;</span>, <span class="number">100</span>);</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;eee&quot;</span>, <span class="number">100</span>);</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;aaa&quot;</span>, <span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 新建HashSet对象 </span></span><br><span class="line">        <span class="type">HashSet</span> <span class="variable">set</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashSet</span>();</span><br><span class="line">        set.add(p1);</span><br><span class="line">        set.add(p2);</span><br><span class="line">        set.add(p3);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 比较p1 和 p2， 并打印它们的hashCode()</span></span><br><span class="line">        System.out.printf(<span class="string">&quot;p1.equals(p2) : %s; p1(%d) p2(%d)\n&quot;</span>, p1.equals(p2), p1.hashCode(), p2.hashCode());</span><br><span class="line">        <span class="comment">// 打印set</span></span><br><span class="line">        System.out.printf(<span class="string">&quot;set:%s\n&quot;</span>, set);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@desc</span> Person类。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">        <span class="type">int</span> age;</span><br><span class="line">        String name;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.name = name;</span><br><span class="line">            <span class="built_in">this</span>.age = age;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;(&quot;</span>+name + <span class="string">&quot;, &quot;</span> +age+<span class="string">&quot;)&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** </span></span><br><span class="line"><span class="comment">         * <span class="doctag">@desc</span> 覆盖equals方法 </span></span><br><span class="line"><span class="comment">         */</span>  </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span>&#123;  </span><br><span class="line">            <span class="keyword">if</span>(obj == <span class="literal">null</span>)&#123;  </span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">            &#125;  </span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果是同一个对象返回true，反之返回false  </span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">this</span> == obj)&#123;  </span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">            &#125;  </span><br><span class="line"></span><br><span class="line">            <span class="comment">//判断是否类型相同  </span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">this</span>.getClass() != obj.getClass())&#123;  </span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">            &#125;  </span><br><span class="line"></span><br><span class="line">            <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> (Person)obj;  </span><br><span class="line">            <span class="keyword">return</span> name.equals(person.name) &amp;&amp; age==person.age;  </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p1.equals(p2) : true; p1(1169863946) p2(1690552137)</span><br><span class="line">set:[(eee, 100), (eee, 100), (aaa, 200)]</span><br></pre></td></tr></table></figure><p>结果分析：</p><p>我们重写了Person的equals()。但是，很奇怪的发现：HashSet中仍然有重复元素：p1 和 p2。为什么会出现这种情况呢？</p><p><strong>这是因为虽然p1 和 p2的内容相等，但是它们的hashCode()不等；所以，HashSet在添加p1和p2的时候，认为它们不相等。</strong></p><p>那同时覆盖equals() 和 hashCode()方法呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.Comparable;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@desc</span> 比较equals() 返回true 以及 返回false时， hashCode()的值。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConflictHashCodeTest2</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 新建Person对象，</span></span><br><span class="line">        <span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;eee&quot;</span>, <span class="number">100</span>);</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;eee&quot;</span>, <span class="number">100</span>);</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;aaa&quot;</span>, <span class="number">200</span>);</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;EEE&quot;</span>, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 新建HashSet对象 </span></span><br><span class="line">        <span class="type">HashSet</span> <span class="variable">set</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashSet</span>();</span><br><span class="line">        set.add(p1);</span><br><span class="line">        set.add(p2);</span><br><span class="line">        set.add(p3);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 比较p1 和 p2， 并打印它们的hashCode()</span></span><br><span class="line">        System.out.printf(<span class="string">&quot;p1.equals(p2) : %s; p1(%d) p2(%d)\n&quot;</span>, p1.equals(p2), p1.hashCode(), p2.hashCode());</span><br><span class="line">        <span class="comment">// 比较p1 和 p4， 并打印它们的hashCode()</span></span><br><span class="line">        System.out.printf(<span class="string">&quot;p1.equals(p4) : %s; p1(%d) p4(%d)\n&quot;</span>, p1.equals(p4), p1.hashCode(), p4.hashCode());</span><br><span class="line">        <span class="comment">// 打印set</span></span><br><span class="line">        System.out.printf(<span class="string">&quot;set:%s\n&quot;</span>, set);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@desc</span> Person类。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">        <span class="type">int</span> age;</span><br><span class="line">        String name;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.name = name;</span><br><span class="line">            <span class="built_in">this</span>.age = age;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> name + <span class="string">&quot; - &quot;</span> +age;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** </span></span><br><span class="line"><span class="comment">         * <span class="doctag">@desc</span>重写hashCode </span></span><br><span class="line"><span class="comment">         */</span>  </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span>&#123;  </span><br><span class="line">            <span class="type">int</span> <span class="variable">nameHash</span> <span class="operator">=</span>  name.toUpperCase().hashCode();</span><br><span class="line">            <span class="keyword">return</span> nameHash ^ age;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** </span></span><br><span class="line"><span class="comment">         * <span class="doctag">@desc</span> 覆盖equals方法 </span></span><br><span class="line"><span class="comment">         */</span>  </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span>&#123;  </span><br><span class="line">            <span class="keyword">if</span>(obj == <span class="literal">null</span>)&#123;  </span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">            &#125;  </span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果是同一个对象返回true，反之返回false  </span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">this</span> == obj)&#123;  </span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">            &#125;  </span><br><span class="line"></span><br><span class="line">            <span class="comment">//判断是否类型相同  </span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">this</span>.getClass() != obj.getClass())&#123;  </span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">            &#125;  </span><br><span class="line"></span><br><span class="line">            <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> (Person)obj;  </span><br><span class="line">            <span class="keyword">return</span> name.equals(person.name) &amp;&amp; age==person.age;  </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p1.equals(p2) : true; p1(68545) p2(68545)</span><br><span class="line">p1.equals(p4) : false; p1(68545) p4(68545)</span><br><span class="line">set:[aaa - 200, eee - 100]</span><br></pre></td></tr></table></figure><p>结果分析：</p><p>这下，equals()生效了，HashSet中没有重复元素。</p><p>比较p1和p2，我们发现：它们的hashCode()相等，通过equals()比较它们也返回true。所以，p1和p2被视为相等。</p><p>比较p1和p4，我们发现：虽然它们的hashCode()相等；但是，通过equals()比较它们返回false。所以，p1和p4被视为不相等。</p><h2 id="原则"><a href="#原则" class="headerlink" title="原则"></a><strong>原则</strong></h2><p>1.<strong>同一个对象（没有发生过修改）无论何时调用hashCode()得到的返回值必须一样。</strong>如果一个key对象在put的时候调用hashCode()决定了存放的位置，而在get的时候调用hashCode()得到了不一样的返回值，这个值映射到了一个和原来不一样的地方，那么肯定就找不到原来那个键值对了。</p><p>2**.hashCode()的返回值相等的对象不一定相等，通过hashCode()和equals()必须能唯一确定一个对象。**不相等的对象的hashCode()的结果可以相等。hashCode()在注意关注碰撞问题的时候，也要关注生成速度问题，完美hash不现实。</p><p>3.<strong>一旦重写了equals()函数（重写equals的时候还要注意要满足自反性、对称性、传递性、一致性），就必须重写hashCode()函数。</strong>而且hashCode()的生成哈希值的依据应该是equals()中用来比较是否相等的字段。</p><p>如果两个由equals()规定相等的对象生成的hashCode不等，对于hashMap来说，他们很可能分别映射到不同位置，没有调用equals()比较是否相等的机会，两个实际上相等的对象可能被插入不同位置，出现错误。其他一些基于哈希方法的集合类可能也会有这个问题</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;面试题&quot;&gt;&lt;a href=&quot;#面试题&quot; class=&quot;headerlink&quot; title=&quot;面试题&quot;&gt;&lt;/a&gt;&lt;strong&gt;面试题&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;【强制】关于hashCode和equals的处理，遵循如下规则：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;</summary>
      
    
    
    
    <category term="Java面试精选" scheme="https://bj-wutz.github.io/categories/Java%E9%9D%A2%E8%AF%95%E7%B2%BE%E9%80%89/"/>
    
    
    <category term="Java" scheme="https://bj-wutz.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>【Java面试精选】【08期】说说Object类下面有几种方法呢？</title>
    <link href="https://bj-wutz.github.io/2022/05/08/%E3%80%90Java%E9%9D%A2%E8%AF%95%E7%B2%BE%E9%80%89%E3%80%91%E3%80%9008%E6%9C%9F%E3%80%91%E8%AF%B4%E8%AF%B4Object%E7%B1%BB%E4%B8%8B%E9%9D%A2%E6%9C%89%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95%E5%91%A2%EF%BC%9F/"/>
    <id>https://bj-wutz.github.io/2022/05/08/%E3%80%90Java%E9%9D%A2%E8%AF%95%E7%B2%BE%E9%80%89%E3%80%91%E3%80%9008%E6%9C%9F%E3%80%91%E8%AF%B4%E8%AF%B4Object%E7%B1%BB%E4%B8%8B%E9%9D%A2%E6%9C%89%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95%E5%91%A2%EF%BC%9F/</id>
    <published>2022-05-08T02:54:33.000Z</published>
    <updated>2022-05-10T11:09:02.242Z</updated>
    
    <content type="html"><![CDATA[<h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a><strong>面试题</strong></h2><p>Object有几种方法呢？</p><ul><li><p>Java语言是一种单继承结构语言，Java中所有的类都有一个共同的祖先。这个祖先就是Object类。</p></li><li><p>如果一个类没有用extends明确指出继承于某个类，那么它默认继承Object类。</p></li><li><p>Object的方法我们在平时基本都会用到，但如果没有准备被忽然这么一问，还是有点懵圈的。</p></li></ul><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a><strong>分析</strong></h2><p>Object类是Java中所有类的基类。位于java.lang包中，一共有13个方法。如下：</p><h2 id="具体解答"><a href="#具体解答" class="headerlink" title="具体解答"></a><strong>具体解答</strong></h2><p>1、Object()</p><p>这个没什么可说的，Object类的构造方法。(非重点)</p><p>2、registerNatives()</p><p>为了使JVM发现本机功能，他们被一定的方式命名。例如，对于java.lang.Object.registerNatives，对应的C函数命名为Java_java_lang_Object_registerNatives。</p><p>通过使用registerNatives（或者更确切地说，JNI函数RegisterNatives），可以命名任何你想要你的C函数。(非重点)</p><p>3、getClass()</p><p>final方法，用于获得运行时的类型。该方法返回的是此Object对象的类对象&#x2F;运行时类对象Class。效果与Object.class相同。（注意：回答这里时可能会引出类加载，反射等知识点的提问）</p><p>4、hashCode()</p><p>该方法用来返回其所在对象的物理地址（哈希码值），常会和equals方法同时重写，确保相等的两个对象拥有相等的hashCode。（注意：可能引出hashmap实现原理的提问）</p><p>5、equals(Object)</p><p>equals用来比较两个对象的内容是否相等。默认情况下(继承自Object类)，equals和&#x3D;&#x3D;是一样的，除非被覆写(override)了。（注意：这里可能引出更常问的“equals与&#x3D;&#x3D;的区别”及hashmap实现原理的提问）</p><p>6、clone()</p><p>clone()函数的用途是用来另存一个当前存在的对象。只有实现了Cloneable接口才可以调用该方法，否则抛出CloneNotSupportedException异常。（注意：回答这里时可能会引出设计模式的提问）</p><p>7、toString()</p><p>toString()方法返回该对象的字符串表示，这个方法没什么可说的。</p><p>8、notify()</p><p>唤醒在此对象监视器上等待的单个线程。（引出线程通信的提问）</p><p>9、notifyAll()</p><p>唤醒在此对象监视器上等待的所有线程。（引出线程通信的提问）</p><p>10、wait(long)</p><p>导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者超过指定的时间量。（引出线程通信及“wait和sleep的区别”的提问）</p><p>11、wait(long, int)</p><p>导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者其他某个线程中断当前线程，或者已超过某个实际时间量。（引出线程通信及“wait和sleep的区别”的提问）</p><p>12、wait()</p><p>导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法。（引出线程通信及“wait和sleep的区别”的提问）</p><p>13、finalize()</p><p>当垃圾回收器确定不存在对该对象的更多引用时，由对象的垃圾回收器调用此方法。（非重点，但小心引出垃圾回收的提问）</p><h2 id="引申常见问题"><a href="#引申常见问题" class="headerlink" title="引申常见问题"></a><strong>引申常见问题</strong></h2><ol><li><p>equals() 与 &#x3D;&#x3D; 的区别是什么？</p></li><li><p>hashCode() 和 equals() 之间有什么联系？</p></li><li><p>wait()方法与sleep()方法的区别</p></li><li><p>为什么重写了equals就必须重写hashCode</p></li><li><p>HashMap的实现原理</p></li><li><p>谈谈类加载机制</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;面试题&quot;&gt;&lt;a href=&quot;#面试题&quot; class=&quot;headerlink&quot; title=&quot;面试题&quot;&gt;&lt;/a&gt;&lt;strong&gt;面试题&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;Object有几种方法呢？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Java语言是一种单继承结构语言，Ja</summary>
      
    
    
    
    <category term="Java面试精选" scheme="https://bj-wutz.github.io/categories/Java%E9%9D%A2%E8%AF%95%E7%B2%BE%E9%80%89/"/>
    
    
    <category term="Java" scheme="https://bj-wutz.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>【Java面试精选】【07期】Redis中是如何实现分布式锁的？</title>
    <link href="https://bj-wutz.github.io/2022/05/07/%E3%80%90Java%E9%9D%A2%E8%AF%95%E7%B2%BE%E9%80%89%E3%80%91%E3%80%9007%E6%9C%9F%E3%80%91Redis%E4%B8%AD%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%EF%BC%9F/"/>
    <id>https://bj-wutz.github.io/2022/05/07/%E3%80%90Java%E9%9D%A2%E8%AF%95%E7%B2%BE%E9%80%89%E3%80%91%E3%80%9007%E6%9C%9F%E3%80%91Redis%E4%B8%AD%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%EF%BC%9F/</id>
    <published>2022-05-07T02:54:32.000Z</published>
    <updated>2022-05-10T11:09:02.240Z</updated>
    
    <content type="html"><![CDATA[<p>分布式锁常见的三种实现方式：</p><ul><li><p>数据库乐观锁；</p></li><li><p>基于Redis的分布式锁；</p></li><li><p>基于ZooKeeper的分布式锁。</p></li></ul><p>本地面试考点是，你对Redis使用熟悉吗？Redis中是如何实现分布式锁的。</p><h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a><strong>要点</strong></h2><p>Redis要实现分布式锁，以下条件应该得到满足</p><ul><li><p>互斥性：在任意时刻，只有一个客户端能持有锁。</p></li><li><p>不能死锁：客户端在持有锁的期间崩溃而没有主动解锁，也能保证后续其他客户端能加锁。</p></li><li><p>容错性：只要大部分的Redis节点正常运行，客户端就可以加锁和解锁。</p></li></ul><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a><strong>实现</strong></h2><p>可以直接通过set key value px milliseconds nx命令实现加锁， 通过Lua脚本实现解锁。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span>获取锁（unique_value可以是UUID等）</span><br><span class="line">SET resource_name unique_value NX PX  <span class="number">30000</span></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>释放锁（lua脚本中，一定要比较value，防止误解锁）</span><br><span class="line"><span class="keyword">if</span> redis.call<span class="punctuation">(</span><span class="string">&quot;get&quot;</span><span class="punctuation">,</span>KEYS<span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span><span class="punctuation">)</span> <span class="operator">==</span> ARGV<span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span> then</span><br><span class="line">    <span class="built_in">return</span> redis.call<span class="punctuation">(</span><span class="string">&quot;del&quot;</span><span class="punctuation">,</span>KEYS<span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span><span class="punctuation">)</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">return</span> <span class="number">0</span></span><br><span class="line">end</span><br></pre></td></tr></table></figure><h3 id="代码解释"><a href="#代码解释" class="headerlink" title="代码解释"></a><strong>代码解释</strong></h3><ul><li><p>set 命令要用 set key value px milliseconds nx，替代 setnx + expire 需要分两次执行命令的方式，保证了原子性，</p></li><li><p>value 要具有唯一性，可以使用UUID.randomUUID().toString()方法生成，用来标识这把锁是属于哪个请求加的，在解锁的时候就可以有依据；</p></li><li><p>释放锁时要验证 value 值，防止误解锁；</p></li><li><p>通过 Lua 脚本来避免 Check And Set 模型的并发问题，因为在释放锁的时候因为涉及到多个Redis操作 （利用了eval命令执行Lua脚本的原子性）；</p></li></ul><h3 id="加锁代码分析"><a href="#加锁代码分析" class="headerlink" title="加锁代码分析"></a><strong>加锁代码分析</strong></h3><p>首先，set()加入了NX参数，可以保证如果已有key存在，则函数不会调用成功，也就是只有一个客户端能持有锁，满足互斥性。其次，由于我们对锁设置了过期时间，即使锁的持有者后续发生崩溃而没有解锁，锁也会因为到了过期时间而自动解锁（即key被删除），不会发生死锁。最后，因为我们将value赋值为requestId，用来标识这把锁是属于哪个请求加的，那么在客户端在解锁的时候就可以进行校验是否是同一个客户端。</p><h3 id="解锁代码分析"><a href="#解锁代码分析" class="headerlink" title="解锁代码分析"></a><strong>解锁代码分析</strong></h3><p>将Lua代码传到jedis.eval()方法里，并使参数KEYS[1]赋值为lockKey，ARGV[1]赋值为requestId。在执行的时候，首先会获取锁对应的value值，检查是否与requestId相等，如果相等则解锁（删除key）。</p><h3 id="存在的风险"><a href="#存在的风险" class="headerlink" title="存在的风险"></a><strong>存在的风险</strong></h3><p>如果存储锁对应key的那个节点挂了的话，就可能存在丢失锁的风险，导致出现多个客户端持有锁的情况，这样就不能实现资源的独享了。</p><ul><li><p>客户端A从master获取到锁</p></li><li><p>在master将锁同步到slave之前，master宕掉了（Redis的主从同步通常是异步的）。主从切换，slave节点被晋级为master节点</p></li><li><p>客户端B取得了同一个资源被客户端A已经获取到的另外一个锁。导致存在同一时刻存不止一个线程获取到锁的情况。</p></li></ul><h2 id="redlock算法出现"><a href="#redlock算法出现" class="headerlink" title="redlock算法出现"></a><strong>redlock算法出现</strong></h2><p>这个场景是假设有一个 redis cluster，有 5 个 redis master 实例。然后执行如下步骤获取一把锁：</p><p>1、获取当前时间戳，单位是毫秒；</p><p>2、跟上面类似，轮流尝试在每个 master 节点上创建锁，过期时间较短，一般就几十毫秒；</p><p>3、尝试在大多数节点上建立一个锁，比如 5 个节点就要求是 3 个节点 n &#x2F; 2 + 1；</p><p>4、客户端计算建立好锁的时间，如果建立锁的时间小于超时时间，就算建立成功了；</p><p>5、要是锁建立失败了，那么就依次之前建立过的锁删除；</p><p>6、只要别人建立了一把分布式锁，你就得不断轮询去尝试获取锁。</p><p><img src="/.%5C%E3%80%90Java%E9%9D%A2%E8%AF%95%E7%B2%BE%E9%80%89%E3%80%91%E3%80%9007%E6%9C%9F%E3%80%91Redis%E4%B8%AD%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%EF%BC%9F%5C1.png"></p><p>Redis 官方给出了以上两种基于 Redis 实现分布式锁的方法，详细说明可以查看：<strong><a href="https://redis.io/topics/distlock">https://redis.io/topics/distlock</a> 。</strong></p><h2 id="Redisson实现"><a href="#Redisson实现" class="headerlink" title="Redisson实现"></a><strong>Redisson实现</strong></h2><p>Redisson是一个在Redis的基础上实现的Java驻内存数据网格（In-Memory Data Grid）。它不仅提供了一系列的分布式的Java常用对象，还实现了可重入锁（Reentrant Lock）、公平锁（Fair Lock、联锁（MultiLock）、 红锁（RedLock）、 读写锁（ReadWriteLock）等，还提供了许多分布式服务。</p><p>Redisson提供了使用Redis的最简单和最便捷的方法。Redisson的宗旨是促进使用者对Redis的关注分离（Separation of Concern），从而让使用者能够将精力更集中地放在处理业务逻辑上。</p><h3 id="Redisson-分布式重入锁用法"><a href="#Redisson-分布式重入锁用法" class="headerlink" title="Redisson 分布式重入锁用法"></a><strong>Redisson 分布式重入锁用法</strong></h3><p>Redisson 支持单点模式、主从模式、哨兵模式、集群模式，这里以单点模式为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.构造redisson实现分布式锁必要的Config</span></span><br><span class="line"><span class="type">Config</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Config</span>();</span><br><span class="line">config.useSingleServer().setAddress(<span class="string">&quot;redis://127.0.0.1:5379&quot;</span>).setPassword(<span class="string">&quot;123456&quot;</span>).setDatabase(<span class="number">0</span>);</span><br><span class="line"><span class="comment">// 2.构造RedissonClient</span></span><br><span class="line"><span class="type">RedissonClient</span> <span class="variable">redissonClient</span> <span class="operator">=</span> Redisson.create(config);</span><br><span class="line"><span class="comment">// 3.获取锁对象实例（无法保证是按线程的顺序获取到）</span></span><br><span class="line"><span class="type">RLock</span> <span class="variable">rLock</span> <span class="operator">=</span> redissonClient.getLock(lockKey);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 4.尝试获取锁</span></span><br><span class="line"><span class="comment">     * waitTimeout 尝试获取锁的最大等待时间，超过这个值，则认为获取锁失败</span></span><br><span class="line"><span class="comment">     * leaseTime   锁的持有时间,超过这个时间锁会自动失效（值应设置为大于业务处理的时间，确保在锁有效期内业务能处理完）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">res</span> <span class="operator">=</span> rLock.tryLock((<span class="type">long</span>)waitTimeout, (<span class="type">long</span>)leaseTime, TimeUnit.SECONDS);</span><br><span class="line">    <span class="keyword">if</span> (res) &#123;</span><br><span class="line">        <span class="comment">//成功获得锁，在这里处理业务</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;aquire lock fail&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    <span class="comment">//无论如何, 最后都要解锁</span></span><br><span class="line">    rLock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>加锁流程图</p><p><img src="/.%5C%E3%80%90Java%E9%9D%A2%E8%AF%95%E7%B2%BE%E9%80%89%E3%80%91%E3%80%9007%E6%9C%9F%E3%80%91Redis%E4%B8%AD%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%EF%BC%9F%5C2.png"></p><p>解锁流程图</p><p><img src="/.%5C%E3%80%90Java%E9%9D%A2%E8%AF%95%E7%B2%BE%E9%80%89%E3%80%91%E3%80%9007%E6%9C%9F%E3%80%91Redis%E4%B8%AD%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%EF%BC%9F%5C3.png"></p><p>我们可以看到，RedissonLock是可重入的，并且考虑了失败重试，可以设置锁的最大等待时间， 在实现上也做了一些优化，减少了无效的锁申请，提升了资源的利用率。</p><p>需要特别注意的是，RedissonLock 同样没有解决 节点挂掉的时候，存在丢失锁的风险的问题。而现实情况是有一些场景无法容忍的，所以 Redisson 提供了实现了redlock算法的 RedissonRedLock，RedissonRedLock 真正解决了单点失败的问题，代价是需要额外的为 RedissonRedLock 搭建Redis环境。</p><p>所以，如果业务场景可以容忍这种小概率的错误，则推荐使用 RedissonLock， 如果无法容忍，则推荐使用 RedissonRedLock。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a><strong>参考</strong></h2><p><strong><a href="https://github.com/javazhiyin/advanced-java/">https://github.com/javazhiyin/advanced-java/</a></strong></p><p><strong><a href="https://crazyfzw.github.io/2019/04/15/distributed-locks-with-redis/">https://crazyfzw.github.io/2019/04/15/distributed-locks-with-redis/</a></strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;分布式锁常见的三种实现方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;数据库乐观锁；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;基于Redis的分布式锁；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;基于ZooKeeper的分布式锁。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本地面试考点是，你对Red</summary>
      
    
    
    
    <category term="Java面试精选" scheme="https://bj-wutz.github.io/categories/Java%E9%9D%A2%E8%AF%95%E7%B2%BE%E9%80%89/"/>
    
    
    <category term="Java" scheme="https://bj-wutz.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>【Java面试精选】【06期】单例模式有几种写法？</title>
    <link href="https://bj-wutz.github.io/2022/05/06/%E3%80%90Java%E9%9D%A2%E8%AF%95%E7%B2%BE%E9%80%89%E3%80%91%E3%80%9006%E6%9C%9F%E3%80%91%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E6%9C%89%E5%87%A0%E7%A7%8D%E5%86%99%E6%B3%95%EF%BC%9F/"/>
    <id>https://bj-wutz.github.io/2022/05/06/%E3%80%90Java%E9%9D%A2%E8%AF%95%E7%B2%BE%E9%80%89%E3%80%91%E3%80%9006%E6%9C%9F%E3%80%91%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E6%9C%89%E5%87%A0%E7%A7%8D%E5%86%99%E6%B3%95%EF%BC%9F/</id>
    <published>2022-05-06T02:54:31.000Z</published>
    <updated>2022-05-10T11:09:02.236Z</updated>
    
    <content type="html"><![CDATA[<h2 id="面试官心理分析"><a href="#面试官心理分析" class="headerlink" title="面试官心理分析"></a><strong>面试官心理分析</strong></h2><p>纠结单例模式有几种写法有用吗？有点用，面试中经常选择其中一种或几种写法作为话头，考查设计模式和coding style的同时，还很容易扩展到其他问题。</p><p>这里讲解几种笔者常用的写法，但切忌生搬硬套，去记“茴香豆的写法”。编程最大的乐趣在于“know everything, control everything”。</p><p>大体可分为4类，下面分别介绍他们的基本形式、变种及特点。</p><h2 id="饱汉模式"><a href="#饱汉模式" class="headerlink" title="饱汉模式"></a><strong>饱汉模式</strong></h2><p>饱汉是变种最多的单例模式。我们从饱汉出发，通过其变种逐渐了解实现单例模式时需要关注的问题。</p><h3 id="基础的饱汉"><a href="#基础的饱汉" class="headerlink" title="基础的饱汉"></a><strong>基础的饱汉</strong></h3><p>饱汉，即已经吃饱，不着急再吃，饿的时候再吃。所以他就先不初始化单例，等第一次使用的时候再初始化，即“懒加载”。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 饱汉</span></span><br><span class="line"><span class="comment">// UnThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton1</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton1</span> <span class="variable">singleton</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">Singleton1</span><span class="params">()</span> &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> Singleton1 <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (singleton == <span class="literal">null</span>) &#123;</span><br><span class="line">      singleton = <span class="keyword">new</span> <span class="title class_">Singleton1</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> singleton;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>饱汉模式的核心就是懒加载。好处是更启动速度快、节省资源，一直到实例被第一次访问，才需要初始化单例；小坏处是写起来麻烦，大坏处是线程不安全，if语句存在竞态条件。</p><p>写起来麻烦不是大问题，可读性好啊。因此，单线程环境下，基础饱汉是笔者最喜欢的写法。但多线程环境下，基础饱汉就彻底不可用了。下面的几种变种都在试图解决基础饱汉线程不安全的问题。</p><h3 id="饱汉-变种-1"><a href="#饱汉-变种-1" class="headerlink" title="饱汉 - 变种 1"></a><strong>饱汉 - 变种 1</strong></h3><p>最粗暴的犯法是用synchronized关键字修饰getInstance()方法，这样能达到绝对的线程安全。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 饱汉</span></span><br><span class="line"><span class="comment">// ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton1_1</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton1_1</span> <span class="variable">singleton</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">Singleton1_1</span><span class="params">()</span> &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> Singleton1_1 <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (singleton == <span class="literal">null</span>) &#123;</span><br><span class="line">      singleton = <span class="keyword">new</span> <span class="title class_">Singleton1_1</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> singleton;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>变种1的好处是写起来简单，且绝对线程安全；坏处是并发性能极差，事实上完全退化到了串行。单例只需要初始化一次，但就算初始化以后，synchronized的锁也无法避开，从而getInstance()完全变成了串行操作。性能不敏感的场景建议使用。</p><h3 id="饱汉-变种-2-DCL-1-0"><a href="#饱汉-变种-2-DCL-1-0" class="headerlink" title="饱汉 - 变种 2 - DCL 1.0"></a><strong>饱汉 - 变种 2 -</strong> <strong>DCL 1.0</strong></h3><p>变种2是“臭名昭著”的DCL 1.0。</p><p>针对变种1中单例初始化后锁仍然无法避开的问题，变种2在变种1的外层又套了一层check，加上synchronized内层的check，即所谓“双重检查锁”（Double Check Lock，简称DCL）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 饱汉</span></span><br><span class="line"><span class="comment">// UnThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton1_2</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton1_2</span> <span class="variable">singleton</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="number">1</span>;   <span class="comment">// 触发部分初始化问题</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="variable">f2</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">Singleton1_2</span><span class="params">()</span> &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> Singleton1_2 <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// may get half object</span></span><br><span class="line">    <span class="keyword">if</span> (singleton == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">synchronized</span> (Singleton1_2.class) &#123;</span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="literal">null</span>) &#123;</span><br><span class="line">          singleton = <span class="keyword">new</span> <span class="title class_">Singleton1_2</span>();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> singleton;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>变种2的核心是DCL，看起来变种2似乎已经达到了理想的效果：懒加载+线程安全。可惜的是，正如注释中所说，DCL仍然是线程不安全的，由于指令重排序，你可能会得到“半个对象”，即”部分初始化“问题。详细在看完变种3后，可参考下面这篇文章，这里不再赘述。</p><h3 id="饱汉-变种-3-DCL-2-0"><a href="#饱汉-变种-3-DCL-2-0" class="headerlink" title="饱汉 - 变种 3 - DCL 2.0"></a><strong>饱汉 - 变种 3 -</strong> <strong>DCL 2.0</strong></h3><p>变种3专门针对变种2，可谓DCL 2.0。</p><p>针对变种3的“半个对象”问题，变种3在instance上增加了volatile关键字，原理见上述参考(<strong><a href="https://monkeysayhi.github.io/2016/11/29/volatile%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%9C%E7%94%A8%E3%80%81%E5%8E%9F%E7%90%86/">https://monkeysayhi.github.io/2016/11/29/volatile关键字的作用、原理/</a></strong>)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 饱汉</span></span><br><span class="line"><span class="comment">// ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton1_3</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">Singleton1_3</span> <span class="variable">singleton</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="number">1</span>;   <span class="comment">// 触发部分初始化问题</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="variable">f2</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">Singleton1_3</span><span class="params">()</span> &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> Singleton1_3 <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (singleton == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">synchronized</span> (Singleton1_3.class) &#123;</span><br><span class="line">        <span class="comment">// must be a complete instance</span></span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="literal">null</span>) &#123;</span><br><span class="line">          singleton = <span class="keyword">new</span> <span class="title class_">Singleton1_3</span>();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> singleton;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多线程环境下，变种3更适用于性能敏感的场景。但后面我们将了解到，就算是线程安全的，还有一些办法能破坏单例。</p><p>当然，还有很多方式，能通过与volatile类似的方式防止部分初始化。读者可自行阅读内存屏障相关内容，但面试时不建议主动装逼。</p><h2 id="饿汉模式"><a href="#饿汉模式" class="headerlink" title="饿汉模式"></a><strong>饿汉模式</strong></h2><p>与饱汉相对，饿汉很饿，只想着尽早吃到。所以他就在最早的时机，即类加载时初始化单例，以后访问时直接返回即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 饿汉</span></span><br><span class="line"><span class="comment">// ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton2</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton2</span> <span class="variable">singleton</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton2</span>();</span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">Singleton2</span><span class="params">()</span> &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> Singleton2 <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> singleton;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>饿汉的好处是天生的线程安全（得益于类加载机制），写起来超级简单，使用时没有延迟；坏处是有可能造成资源浪费（如果类加载后就一直不使用单例的话）。</p><p><strong>值得注意的时，单线程环境下，饿汉与饱汉在性能上没什么差别；但多线程环境下，由于饱汉需要加锁，饿汉的性能反而更优。</strong></p><h2 id="Holder模式"><a href="#Holder模式" class="headerlink" title="Holder模式"></a><strong>Holder模式</strong></h2><p>我们既希望利用饿汉模式中静态变量的方便和线程安全；又希望通过懒加载规避资源浪费。Holder模式满足了这两点要求：核心仍然是静态变量，足够方便和线程安全；通过静态的Holder类持有真正实例，间接实现了懒加载。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Holder模式</span></span><br><span class="line"><span class="comment">// ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton3</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonHolder</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton3</span> <span class="variable">singleton</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton3</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SingletonHolder</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">Singleton3</span><span class="params">()</span> &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> Singleton3 <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> SingletonHolder.singleton;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相对于饿汉模式，Holder模式仅增加了一个静态内部类的成本，与饱汉的变种3效果相当（略优），都是比较受欢迎的实现方式。同样建议考虑。</p><h2 id="枚举模式"><a href="#枚举模式" class="headerlink" title="枚举模式"></a><strong>枚举模式</strong></h2><p>用枚举实现单例模式，相当好用，但可读性是不存在的。</p><h3 id="基础的枚举"><a href="#基础的枚举" class="headerlink" title="基础的枚举"></a><strong>基础的枚举</strong></h3><p>将枚举的静态成员变量作为单例的实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 枚举</span></span><br><span class="line"><span class="comment">// ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Singleton4</span> &#123;</span><br><span class="line">  SINGLETON;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码量比饿汉模式更少。但用户只能直接访问实例Singleton4.SINGLETON——事实上，这样的访问方式作为单例使用也是恰当的，只是牺牲了静态工厂方法的优点，如无法实现懒加载。</p><p>Java的枚举是一个“丑陋但好用的语法糖”。</p><h3 id="枚举型单例模式的本质"><a href="#枚举型单例模式的本质" class="headerlink" title="枚举型单例模式的本质"></a><strong>枚举型单例模式的本质</strong></h3><p>通过反编译打开语法糖，就看到了枚举类型的本质，简化如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 枚举</span></span><br><span class="line"><span class="comment">// ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton4</span> <span class="keyword">extends</span> <span class="title class_">Enum</span>&lt;Singleton4&gt; &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton4</span> <span class="variable">SINGLETON</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton4</span>();</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本质上和饿汉模式相同，区别仅在于公有的静态成员变量。</p><h3 id="用枚举实现一些trick"><a href="#用枚举实现一些trick" class="headerlink" title="用枚举实现一些trick"></a><strong>用枚举实现一些trick</strong></h3><p><strong>这一部分与单例没什么关系，可以跳过。如果选择阅读也请认清这样的事实：虽然枚举相当灵活，但如何恰当的使用枚举有一定难度。一个足够简单的典型例子是TimeUnit类，建议有时间耐心阅读。</strong></p><p>上面已经看到，枚举型单例的本质仍然是一个普通的类。实际上，我们可以在枚举型型单例上增加任何普通类可以完成的功能。要点在于枚举实例的初始化，可以理解为实例化了一个匿名内部类。为了更明显，我们在Singleton4_1中定义一个普通的私有成员变量，一个普通的公有成员方法，和一个公有的抽象成员方法，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 枚举</span></span><br><span class="line"><span class="comment">// ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Singleton4_1</span> &#123;</span><br><span class="line">  SINGLETON(<span class="string">&quot;enum is the easiest singleton pattern, but not the most readable&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testAbsMethod</span><span class="params">()</span> &#123;</span><br><span class="line">      print();</span><br><span class="line">      System.out.println(<span class="string">&quot;enum is ugly, but so flexible to make lots of trick&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">String</span> <span class="variable">comment</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">  Singleton4_1(String comment) &#123;</span><br><span class="line">    <span class="built_in">this</span>.comment = comment;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;comment=&quot;</span> + comment);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">abstract</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testAbsMethod</span><span class="params">()</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> Singleton4_1 <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> SINGLETON;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，枚举类Singleton4_1中的每一个枚举实例不仅继承了父类Singleton4_1的成员方法print()，还必须实现父类Singleton4_1的抽象成员方法testAbsMethod()。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><p>上面的分析都忽略了反射和序列化的问题。通过反射或序列化，我们仍然能够访问到私有构造器，创建新的实例破坏单例模式。此时，只有枚举模式能天然防范这一问题。反射和序列化笔者还不太了解，但基本原理并不难，可以在其他模式上手动实现。</p><p>下面继续忽略反射和序列化的问题，做个总结回味一下：</p><table><thead><tr><th>实现方式</th><th>关键点</th><th>资源浪费</th><th>线程安全</th><th>多线程环境的性能足够优化</th></tr></thead><tbody><tr><td>基础饱汉</td><td>懒加载</td><td>否</td><td>否</td><td>-</td></tr><tr><td>饱汉变种1</td><td>懒加载、同步</td><td>否</td><td>是</td><td>否</td></tr><tr><td>饱汉变种2</td><td>懒加载、DCL</td><td>否</td><td>否</td><td>-</td></tr><tr><td>饱汉变种3</td><td>懒加载、DCL、volatile</td><td>否</td><td>是</td><td>是</td></tr><tr><td>饿汉</td><td>静态变量初始化</td><td>是</td><td>是</td><td>是</td></tr><tr><td>Holder</td><td>静态变量初始化、holder</td><td>是</td><td>是</td><td>是</td></tr><tr><td>枚举</td><td>枚举本质、静态变量初始化</td><td>否</td><td>是</td><td>是</td></tr></tbody></table><p>单例模式是面试中的常考点，写起来非常简单。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;面试官心理分析&quot;&gt;&lt;a href=&quot;#面试官心理分析&quot; class=&quot;headerlink&quot; title=&quot;面试官心理分析&quot;&gt;&lt;/a&gt;&lt;strong&gt;面试官心理分析&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;纠结单例模式有几种写法有用吗？有点用，面试中经常选择其中一种或几种</summary>
      
    
    
    
    <category term="Java面试精选" scheme="https://bj-wutz.github.io/categories/Java%E9%9D%A2%E8%AF%95%E7%B2%BE%E9%80%89/"/>
    
    
    <category term="Java" scheme="https://bj-wutz.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>【Java面试精选】【05期】消息队列中，如何保证消息的顺序性？</title>
    <link href="https://bj-wutz.github.io/2022/05/05/%E3%80%90Java%E9%9D%A2%E8%AF%95%E7%B2%BE%E9%80%89%E3%80%91%E3%80%9005%E6%9C%9F%E3%80%91%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E4%B8%AD%EF%BC%8C%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%B6%88%E6%81%AF%E7%9A%84%E9%A1%BA%E5%BA%8F%E6%80%A7%EF%BC%9F/"/>
    <id>https://bj-wutz.github.io/2022/05/05/%E3%80%90Java%E9%9D%A2%E8%AF%95%E7%B2%BE%E9%80%89%E3%80%91%E3%80%9005%E6%9C%9F%E3%80%91%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E4%B8%AD%EF%BC%8C%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%B6%88%E6%81%AF%E7%9A%84%E9%A1%BA%E5%BA%8F%E6%80%A7%EF%BC%9F/</id>
    <published>2022-05-05T02:54:30.000Z</published>
    <updated>2022-05-10T11:09:02.246Z</updated>
    
    <content type="html"><![CDATA[<h2 id="面试官心理分析"><a href="#面试官心理分析" class="headerlink" title="面试官心理分析"></a><strong>面试官心理分析</strong></h2><p>其实这个也是用 MQ 的时候必问的话题，第一看看你了不了解顺序这个事儿？第二看看你有没有办法保证消息是有顺序的？这是生产系统中常见的问题。</p><h2 id="面试题剖析"><a href="#面试题剖析" class="headerlink" title="面试题剖析"></a><strong>面试题剖析</strong></h2><p>我举个例子，我们以前做过一个 mysql binlog 同步的系统，压力还是非常大的，日同步数据要达到上亿，就是说数据从一个 mysql 库原封不动地同步到另一个 mysql 库里面去（mysql -&gt; mysql）。常见的一点在于说比如大数据 team，就需要同步一个 mysql 库过来，对公司的业务系统的数据做各种复杂的操作。</p><p>你在 mysql 里增删改一条数据，对应出来了增删改 3 条 binlog 日志，接着这三条 binlog 发送到 MQ 里面，再消费出来依次执行，起码得保证人家是按照顺序来的吧？不然本来是：增加、修改、删除；你楞是换了顺序给执行成删除、修改、增加，不全错了么。</p><p>本来这个数据同步过来，应该最后这个数据被删除了；结果你搞错了这个顺序，最后这个数据保留下来了，数据同步就出错了。</p><h2 id="先看看顺序会错乱的俩场景"><a href="#先看看顺序会错乱的俩场景" class="headerlink" title="先看看顺序会错乱的俩场景"></a><strong>先看看顺序会错乱的俩场景</strong></h2><p><strong>RabbitMQ</strong></p><p>一个 queue，多个 consumer。比如，生产者向 RabbitMQ 里发送了三条数据，顺序依次是 data1&#x2F;data2&#x2F;data3，压入的是 RabbitMQ 的一个内存队列。有三个消费者分别从 MQ 中消费这三条数据中的一条，结果消费者2先执行完操作，把 data2 存入数据库，然后是 data1&#x2F;data3。这不明显乱了。</p><p><img src="/.%5C%E3%80%90Java%E9%9D%A2%E8%AF%95%E7%B2%BE%E9%80%89%E3%80%91%E3%80%9005%E6%9C%9F%E3%80%91%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E4%B8%AD%EF%BC%8C%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%B6%88%E6%81%AF%E7%9A%84%E9%A1%BA%E5%BA%8F%E6%80%A7%EF%BC%9F%5C1.png"></p><p><strong>Kafka</strong></p><p>比如说我们建了一个 topic，有三个 partition。生产者在写的时候，其实可以指定一个 key，比如说我们指定了某个订单 id 作为 key，那么这个订单相关的数据，一定会被分发到同一个 partition 中去，而且这个 partition 中的数据一定是有顺序的。</p><p>消费者从 partition 中取出来数据的时候，也一定是有顺序的。到这里，顺序还是 ok 的，没有错乱。接着，我们在消费者里可能会搞多个线程来并发处理消息。因为如果消费者是单线程消费处理，而处理比较耗时的话，比如处理一条消息耗时几十 ms，那么 1 秒钟只能处理几十条消息，这吞吐量太低了。而多个线程并发跑的话，顺序可能就乱掉了。</p><p><img src="/.%5C%E3%80%90Java%E9%9D%A2%E8%AF%95%E7%B2%BE%E9%80%89%E3%80%91%E3%80%9005%E6%9C%9F%E3%80%91%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E4%B8%AD%EF%BC%8C%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%B6%88%E6%81%AF%E7%9A%84%E9%A1%BA%E5%BA%8F%E6%80%A7%EF%BC%9F%5C2.png"></p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a><strong>解决方案</strong></h2><p><strong>RabbitMQ</strong></p><p>拆分多个 queue，每个 queue 一个 consumer，就是多一些 queue 而已，确实是麻烦点；或者就一个 queue 但是对应一个 consumer，然后这个 consumer 内部用内存队列做排队，然后分发给底层不同的 worker 来处理。</p><p><img src="/.%5C%E3%80%90Java%E9%9D%A2%E8%AF%95%E7%B2%BE%E9%80%89%E3%80%91%E3%80%9005%E6%9C%9F%E3%80%91%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E4%B8%AD%EF%BC%8C%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%B6%88%E6%81%AF%E7%9A%84%E9%A1%BA%E5%BA%8F%E6%80%A7%EF%BC%9F%5C3.png"></p><p><strong>Kafka</strong></p><p>一个 topic，一个 partition，一个 consumer，内部单线程消费，单线程吞吐量太低，一般不会用这个。</p><p>写 N 个内存 queue，具有相同 key 的数据都到同一个内存 queue；然后对于 N 个线程，每个线程分别消费一个内存 queue 即可，这样就能保证顺序性。</p><p><img src="/.%5C%E3%80%90Java%E9%9D%A2%E8%AF%95%E7%B2%BE%E9%80%89%E3%80%91%E3%80%9005%E6%9C%9F%E3%80%91%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E4%B8%AD%EF%BC%8C%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%B6%88%E6%81%AF%E7%9A%84%E9%A1%BA%E5%BA%8F%E6%80%A7%EF%BC%9F%5C4.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;面试官心理分析&quot;&gt;&lt;a href=&quot;#面试官心理分析&quot; class=&quot;headerlink&quot; title=&quot;面试官心理分析&quot;&gt;&lt;/a&gt;&lt;strong&gt;面试官心理分析&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;其实这个也是用 MQ 的时候必问的话题，第一看看你了不了解顺序这个</summary>
      
    
    
    
    <category term="Java面试精选" scheme="https://bj-wutz.github.io/categories/Java%E9%9D%A2%E8%AF%95%E7%B2%BE%E9%80%89/"/>
    
    
    <category term="Java" scheme="https://bj-wutz.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>【Java面试精选】【04期】分库分表之后，id 主键如何处理？</title>
    <link href="https://bj-wutz.github.io/2022/05/04/%E3%80%90Java%E9%9D%A2%E8%AF%95%E7%B2%BE%E9%80%89%E3%80%91%E3%80%9004%E6%9C%9F%E3%80%91%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E4%B9%8B%E5%90%8E%EF%BC%8Cid-%E4%B8%BB%E9%94%AE%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%EF%BC%9F/"/>
    <id>https://bj-wutz.github.io/2022/05/04/%E3%80%90Java%E9%9D%A2%E8%AF%95%E7%B2%BE%E9%80%89%E3%80%91%E3%80%9004%E6%9C%9F%E3%80%91%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E4%B9%8B%E5%90%8E%EF%BC%8Cid-%E4%B8%BB%E9%94%AE%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%EF%BC%9F/</id>
    <published>2022-05-04T02:54:29.000Z</published>
    <updated>2022-05-10T11:09:02.227Z</updated>
    
    <content type="html"><![CDATA[<h2 id="面试官心理分析"><a href="#面试官心理分析" class="headerlink" title="面试官心理分析"></a><strong>面试官心理分析</strong></h2><p>其实这是分库分表之后你必然要面对的一个问题，就是 id 咋生成？因为要是分成多个表之后，每个表都是从 1 开始累加，那肯定不对啊，需要一个全局唯一的 id 来支持。所以这都是你实际生产环境中必须考虑的问题。</p><h2 id="面试题剖析"><a href="#面试题剖析" class="headerlink" title="面试题剖析"></a><strong>面试题剖析</strong></h2><h3 id="基于数据库的实现方案"><a href="#基于数据库的实现方案" class="headerlink" title="基于数据库的实现方案"></a><strong>基于数据库的实现方案</strong></h3><p><strong>数据库自增 id</strong></p><p>这个就是说你的系统里每次得到一个 id，都是往一个库的一个表里插入一条没什么业务含义的数据，然后获取一个数据库自增的一个 id。拿到这个 id 之后再往对应的分库分表里去写入。</p><p>这个方案的好处就是方便简单，谁都会用；<strong>缺点就是单库生成自增</strong> id，要是高并发的话，就会有瓶颈的；如果你硬是要改进一下，那么就专门开一个服务出来，这个服务每次就拿到当前 id 最大值，然后自己递增几个 id，一次性返回一批 id，然后再把当前最大 id 值修改成递增几个 id 之后的一个值；但是<strong>无论如何都是基于单个数据库</strong>。</p><p><strong>适合的场景：</strong>你分库分表就俩原因，要不就是单库并发太高，要不就是单库数据量太大；除非是你<strong>并发不高，但是数据量太大</strong>导致的分库分表扩容，你可以用这个方案，因为可能每秒最高并发最多就几百，那么就走单独的一个库和表生成自增主键即可。</p><p><strong>设置数据库 sequence 或者表自增字段步长</strong></p><p>可以通过设置数据库 sequence 或者表的自增字段步长来进行水平伸缩。</p><p>比如说，现在有 8 个服务节点，每个服务节点使用一个 sequence 功能来产生 ID，每个 sequence 的起始 ID 不同，并且依次递增，步长都是 8。</p><p><strong>适合的场景：</strong>在用户防止产生的 ID 重复时，这种方案实现起来比较简单，也能达到性能目标。但是服务节点固定，步长也固定，将来如果还要增加服务节点，就不好搞了。</p><p><img src="/.%5C%E3%80%90Java%E9%9D%A2%E8%AF%95%E7%B2%BE%E9%80%89%E3%80%91%E3%80%9004%E6%9C%9F%E3%80%91%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E4%B9%8B%E5%90%8E%EF%BC%8Cid-%E4%B8%BB%E9%94%AE%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%EF%BC%9F%5C1.png"></p><h3 id="UUID"><a href="#UUID" class="headerlink" title="UUID"></a><strong>UUID</strong></h3><p>好处就是本地生成，不要基于数据库来了；不好之处就是，UUID 太长了、占用空间大，<strong>作为主键性能太差了</strong>；更重要的是，UUID 不具有有序性，会导致 B+ 树索引在写的时候有过多的随机写操作（连续的 ID 可以产生部分顺序写），还有，由于在写的时候不能产生有顺序的 append 操作，而需要进行 insert 操作，将会读取整个 B+ 树节点到内存，在插入这条记录后会将整个节点写回磁盘，这种操作在记录占用空间比较大的情况下，性能下降明显。</p><p>适合的场景：如果你是要随机生成个什么文件名、编号之类的，你可以用 UUID，但是作为主键是不能用 UUID 的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UUID.randomUUID().toString().replace(“-”, “”) -&gt; sfsdf23423rr234sfdaf</span><br></pre></td></tr></table></figure><h3 id="获取系统当前时间"><a href="#获取系统当前时间" class="headerlink" title="获取系统当前时间"></a><strong>获取系统当前时间</strong></h3><p>这个就是获取当前时间即可，但是问题是，<strong>并发很高的时候</strong>，比如一秒并发几千，<strong>会有重复的情况</strong>，这个是肯定不合适的。基本就不用考虑了。</p><p><strong>适合的场景：</strong>一般如果用这个方案，是将当前时间跟很多其他的业务字段拼接起来，作为一个 id，如果业务上你觉得可以接受，那么也是可以的。你可以将别的业务字段值跟当前时间拼接起来，组成一个全局唯一的编号。</p><h3 id="snowflake-算法"><a href="#snowflake-算法" class="headerlink" title="snowflake 算法"></a><strong>snowflake 算法</strong></h3><p>snowflake 算法是 twitter 开源的分布式 id 生成算法，采用 Scala 语言实现，是把一个 64 位的 long 型的 id，1 个 bit 是不用的，用其中的 41 bit 作为毫秒数，用 10 bit 作为工作机器 id，12 bit 作为序列号。</p><ul><li><p>1 bit：不用，为啥呢？因为二进制里第一个 bit 为如果是 1，那么都是负数，但是我们生成的 id 都是正数，所以第一个 bit 统一都是 0。</p></li><li><p>41 bit：表示的是时间戳，单位是毫秒。41 bit 可以表示的数字多达 2^41 - 1，也就是可以标识 2^41 - 1 个毫秒值，换算成年就是表示69年的时间。</p></li><li><p>10 bit：记录工作机器 id，代表的是这个服务最多可以部署在 2^10台机器上哪，也就是1024台机器。但是 10 bit 里 5 个 bit 代表机房 id，5 个 bit 代表机器 id。意思就是最多代表 2^5个机房（32个机房），每个机房里可以代表 2^5 个机器（32台机器）。</p></li><li><p>12 bit：这个是用来记录同一个毫秒内产生的不同 id，12 bit 可以代表的最大正整数是 2^12 - 1 &#x3D; 4096，也就是说可以用这个 12 bit 代表的数字来区分同一个毫秒内的 4096 个不同的 id。</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 | 0001100 10100010 10111110 10001001 01011100 00 | 10001 | 1 1001 | 0000 00000000</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IdWorker</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> workerId;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> datacenterId;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> sequence;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">IdWorker</span><span class="params">(<span class="type">long</span> workerId, <span class="type">long</span> datacenterId, <span class="type">long</span> sequence)</span> &#123;</span><br><span class="line">        <span class="comment">// sanity check for workerId</span></span><br><span class="line">        <span class="comment">// 这儿不就检查了一下，要求就是你传递进来的机房id和机器id不能超过32，不能小于0</span></span><br><span class="line">        <span class="keyword">if</span> (workerId &gt; maxWorkerId || workerId &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(</span><br><span class="line">                    String.format(<span class="string">&quot;worker Id can&#x27;t be greater than %d or less than 0&quot;</span>, maxWorkerId));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (datacenterId &gt; maxDatacenterId || datacenterId &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(</span><br><span class="line">                    String.format(<span class="string">&quot;datacenter Id can&#x27;t be greater than %d or less than 0&quot;</span>, maxDatacenterId));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.printf(</span><br><span class="line">                <span class="string">&quot;worker starting. timestamp left shift %d, datacenter id bits %d, worker id bits %d, sequence bits %d, workerid %d&quot;</span>,</span><br><span class="line">                timestampLeftShift, datacenterIdBits, workerIdBits, sequenceBits, workerId);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.workerId = workerId;</span><br><span class="line">        <span class="built_in">this</span>.datacenterId = datacenterId;</span><br><span class="line">        <span class="built_in">this</span>.sequence = sequence;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> <span class="variable">twepoch</span> <span class="operator">=</span> <span class="number">1288834974657L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> <span class="variable">workerIdBits</span> <span class="operator">=</span> <span class="number">5L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> <span class="variable">datacenterIdBits</span> <span class="operator">=</span> <span class="number">5L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个是二进制运算，就是 5 bit最多只能有31个数字，也就是说机器id最多只能是32以内</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> <span class="variable">maxWorkerId</span> <span class="operator">=</span> -<span class="number">1L</span> ^ (-<span class="number">1L</span> &lt;&lt; workerIdBits);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个是一个意思，就是 5 bit最多只能有31个数字，机房id最多只能是32以内</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> <span class="variable">maxDatacenterId</span> <span class="operator">=</span> -<span class="number">1L</span> ^ (-<span class="number">1L</span> &lt;&lt; datacenterIdBits);</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> <span class="variable">sequenceBits</span> <span class="operator">=</span> <span class="number">12L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> <span class="variable">workerIdShift</span> <span class="operator">=</span> sequenceBits;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> <span class="variable">datacenterIdShift</span> <span class="operator">=</span> sequenceBits + workerIdBits;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> <span class="variable">timestampLeftShift</span> <span class="operator">=</span> sequenceBits + workerIdBits + datacenterIdBits;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> <span class="variable">sequenceMask</span> <span class="operator">=</span> -<span class="number">1L</span> ^ (-<span class="number">1L</span> &lt;&lt; sequenceBits);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> <span class="variable">lastTimestamp</span> <span class="operator">=</span> -<span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getWorkerId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> workerId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getDatacenterId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> datacenterId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getTimestamp</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">long</span> <span class="title function_">nextId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 这儿就是获取当前时间戳，单位是毫秒</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">timestamp</span> <span class="operator">=</span> timeGen();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (timestamp &lt; lastTimestamp) &#123;</span><br><span class="line">            System.err.printf(<span class="string">&quot;clock is moving backwards.  Rejecting requests until %d.&quot;</span>, lastTimestamp);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(String.format(</span><br><span class="line">                    <span class="string">&quot;Clock moved backwards.  Refusing to generate id for %d milliseconds&quot;</span>, lastTimestamp - timestamp));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (lastTimestamp == timestamp) &#123;</span><br><span class="line">            <span class="comment">// 这个意思是说一个毫秒内最多只能有4096个数字</span></span><br><span class="line">            <span class="comment">// 无论你传递多少进来，这个位运算保证始终就是在4096这个范围内，避免你自己传递个sequence超过了4096这个范围</span></span><br><span class="line">            sequence = (sequence + <span class="number">1</span>) &amp; sequenceMask;</span><br><span class="line">            <span class="keyword">if</span> (sequence == <span class="number">0</span>) &#123;</span><br><span class="line">                timestamp = tilNextMillis(lastTimestamp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            sequence = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这儿记录一下最近一次生成id的时间戳，单位是毫秒</span></span><br><span class="line">        lastTimestamp = timestamp;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这儿就是将时间戳左移，放到 41 bit那儿；</span></span><br><span class="line">        <span class="comment">// 将机房 id左移放到 5 bit那儿；</span></span><br><span class="line">        <span class="comment">// 将机器id左移放到5 bit那儿；将序号放最后12 bit；</span></span><br><span class="line">        <span class="comment">// 最后拼接起来成一个 64 bit的二进制数字，转换成 10 进制就是个 long 型</span></span><br><span class="line">        <span class="keyword">return</span> ((timestamp - twepoch) &lt;&lt; timestampLeftShift) | (datacenterId &lt;&lt; datacenterIdShift)</span><br><span class="line">                | (workerId &lt;&lt; workerIdShift) | sequence;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> <span class="title function_">tilNextMillis</span><span class="params">(<span class="type">long</span> lastTimestamp)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">timestamp</span> <span class="operator">=</span> timeGen();</span><br><span class="line">        <span class="keyword">while</span> (timestamp &lt;= lastTimestamp) &#123;</span><br><span class="line">            timestamp = timeGen();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> timestamp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> <span class="title function_">timeGen</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ---------------测试---------------</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">IdWorker</span> <span class="variable">worker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IdWorker</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">30</span>; i++) &#123;</span><br><span class="line">            System.out.println(worker.nextId());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>怎么说呢，大概这个意思吧，就是说 41 bit 是当前毫秒单位的一个时间戳，就这意思；然后 5 bit 是你传递进来的一个机房 id（但是最大只能是 32 以内），另外 5 bit 是你传递进来的机器 id（但是最大只能是 32 以内），剩下的那个 12 bit序列号，就是如果跟你上次生成 id 的时间还在一个毫秒内，那么会把顺序给你累加，最多在 4096 个序号以内。</p><p>所以你自己利用这个工具类，自己搞一个服务，然后对每个机房的每个机器都初始化这么一个东西，刚开始这个机房的这个机器的序号就是 0。然后每次接收到一个请求，说这个机房的这个机器要生成一个 id，你就找到对应的 Worker 生成。</p><p>利用这个 snowflake 算法，你可以开发自己公司的服务，甚至对于机房 id 和机器 id，反正给你预留了 5 bit + 5 bit，你换成别的有业务含义的东西也可以的。</p><p>这个 snowflake 算法相对来说还是比较靠谱的，所以你要真是搞分布式 id 生成，如果是高并发啥的，那么用这个应该性能比较好，一般每秒几万并发的场景，也足够你用了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;面试官心理分析&quot;&gt;&lt;a href=&quot;#面试官心理分析&quot; class=&quot;headerlink&quot; title=&quot;面试官心理分析&quot;&gt;&lt;/a&gt;&lt;strong&gt;面试官心理分析&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;其实这是分库分表之后你必然要面对的一个问题，就是 id 咋生成？因</summary>
      
    
    
    
    <category term="Java面试精选" scheme="https://bj-wutz.github.io/categories/Java%E9%9D%A2%E8%AF%95%E7%B2%BE%E9%80%89/"/>
    
    
    <category term="Java" scheme="https://bj-wutz.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>【Java面试精选】【03期】如何决定使用 HashMap 还是 TreeMap？</title>
    <link href="https://bj-wutz.github.io/2022/05/03/%E3%80%90Java%E9%9D%A2%E8%AF%95%E7%B2%BE%E9%80%89%E3%80%91%E3%80%9003%E6%9C%9F%E3%80%91%E5%A6%82%E4%BD%95%E5%86%B3%E5%AE%9A%E4%BD%BF%E7%94%A8-HashMap-%E8%BF%98%E6%98%AF-TreeMap%EF%BC%9F/"/>
    <id>https://bj-wutz.github.io/2022/05/03/%E3%80%90Java%E9%9D%A2%E8%AF%95%E7%B2%BE%E9%80%89%E3%80%91%E3%80%9003%E6%9C%9F%E3%80%91%E5%A6%82%E4%BD%95%E5%86%B3%E5%AE%9A%E4%BD%BF%E7%94%A8-HashMap-%E8%BF%98%E6%98%AF-TreeMap%EF%BC%9F/</id>
    <published>2022-05-03T02:54:29.000Z</published>
    <updated>2022-05-10T11:09:02.255Z</updated>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a><strong>介绍</strong></h2><p>TreeMap&lt;K,V&gt;的Key值是要求实现java.lang.Comparable，所以迭代的时候TreeMap默认是按照Key值升序排序的；TreeMap的实现是基于红黑树结构。适用于按自然顺序或自定义顺序遍历键（key）。</p><p>HashMap&lt;K,V&gt;的Key值实现散列hashCode()，分布是散列的、均匀的，不支持排序；数据结构主要是桶(数组)，链表或红黑树。适用于在Map中插入、删除和定位元素。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a><strong>结论</strong></h2><p>如果你需要得到一个有序的结果时就应该使用TreeMap（因为HashMap中元素的排列顺序是不固定的）。除此之外，由于HashMap有更好的性能，所以大多不需要排序的时候我们会使用HashMap。</p><h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a><strong>拓展</strong></h2><h3 id="1、HashMap-和-TreeMap-的实现"><a href="#1、HashMap-和-TreeMap-的实现" class="headerlink" title="1、HashMap 和 TreeMap 的实现"></a><strong>1、HashMap 和 TreeMap 的实现</strong></h3><p><strong>HashMap：</strong>基于哈希表实现。使用HashMap要求添加的键类明确定义了hashCode()和equals()[可以重写hashCode()和equals()]，为了优化HashMap空间的使用，您可以调优初始容量和负载因子。</p><ul><li><p>HashMap(): 构建一个空的哈希映像</p></li><li><p>HashMap(Map m): 构建一个哈希映像，并且添加映像m的所有映射</p></li><li><p>HashMap(int initialCapacity): 构建一个拥有特定容量的空的哈希映像</p></li><li><p>HashMap(int initialCapacity, float loadFactor): 构建一个拥有特定容量和加载因子的空的哈希映像</p></li></ul><p><strong>TreeMap：</strong>基于红黑树实现。TreeMap没有调优选项，因为该树总处于平衡状态。</p><ul><li><p>TreeMap()：构建一个空的映像树</p></li><li><p>TreeMap(Map m): 构建一个映像树，并且添加映像m中所有元素</p></li><li><p>TreeMap(Comparator c): 构建一个映像树，并且使用特定的比较器对关键字进行排序</p></li><li><p>TreeMap(SortedMap s): 构建一个映像树，添加映像树s中所有映射，并且使用与有序映像s相同的比较器排序</p></li></ul><h3 id="2、HashMap-和-TreeMap-都是非线程安全"><a href="#2、HashMap-和-TreeMap-都是非线程安全" class="headerlink" title="2、HashMap 和 TreeMap 都是非线程安全"></a><strong>2、HashMap 和 TreeMap 都是非线程安全</strong></h3><p>HashMap继承AbstractMap抽象类，TreeMap继承自SortedMap接口。</p><p><strong>AbstractMap抽象类</strong>：覆盖了equals()和hashCode()方法以确保两个相等映射返回相同的哈希码。如果两个映射大小相等、包含同样的键且每个键在这两个映射中对应的值都相同，则这两个映射相等。映射的哈希码是映射元素哈希码的总和，其中每个元素是Map.Entry接口的一个实现。因此，不论映射内部顺序如何，两个相等映射会报告相同的哈希码。</p><p><strong>SortedMap接口</strong>：它用来保持键的有序顺序。SortedMap接口为映像的视图(子集)，包括两个端点提供了访问方法。除了排序是作用于映射的键以外，处理SortedMap和处理SortedSet一样。添加到SortedMap实现类的元素必须实现Comparable接口，否则您必须给它的构造函数提供一个Comparator接口的实现。TreeMap类是它的唯一一个实现。</p><h3 id="3、TreeMap中默认是按照升序进行排序的，如何让他降序"><a href="#3、TreeMap中默认是按照升序进行排序的，如何让他降序" class="headerlink" title="3、TreeMap中默认是按照升序进行排序的，如何让他降序"></a><strong>3、TreeMap中默认是按照升序进行排序的，如何让他降序</strong></h3><p>通过自定义的比较器来实现</p><p>定义一个比较器类，实现Comparator接口，重写compare方法，有两个参数，这两个参数通过调用compareTo进行比较，而compareTo默认规则是：</p><ul><li>如果参数字符串等于此字符串，则返回 0 值；</li><li>如果此字符串小于字符串参数，则返回一个小于 0 的值；</li><li>如果此字符串大于字符串参数，则返回一个大于 0 的值。</li></ul><p>自定义比较器时，在返回时多添加了个负号，就将比较的结果以相反的形式返回，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyComparator</span> <span class="keyword">implements</span> <span class="title class_">Comparator</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Object o1, Object o2)</span> &#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">param1</span> <span class="operator">=</span> (String)o1;</span><br><span class="line">        <span class="type">String</span> <span class="variable">param2</span> <span class="operator">=</span> (String)o2;</span><br><span class="line">        <span class="keyword">return</span> -param1.compareTo(param2);</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后，通过MyComparator类初始化一个比较器实例，将其作为参数传进TreeMap的构造方法中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">MyComparator</span> <span class="variable">comparator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyComparator</span>();</span><br><span class="line"></span><br><span class="line">Map&lt;String,String&gt; map = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;String,String&gt;(comparator);</span><br></pre></td></tr></table></figure><p>这样，我们就可以使用自定义的比较器实现降序了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;&lt;strong&gt;介绍&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;TreeMap&amp;lt;K,V&amp;gt;的Key值是要求实现java.lang.Comparable，所以迭代</summary>
      
    
    
    
    <category term="Java面试精选" scheme="https://bj-wutz.github.io/categories/Java%E9%9D%A2%E8%AF%95%E7%B2%BE%E9%80%89/"/>
    
    
    <category term="Java" scheme="https://bj-wutz.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>【Java面试精选】【02期】你能说说Spring框架中Bean的生命周期吗？</title>
    <link href="https://bj-wutz.github.io/2022/05/02/%E3%80%90Java%E9%9D%A2%E8%AF%95%E7%B2%BE%E9%80%89%E3%80%91%E3%80%9002%E6%9C%9F%E3%80%91%E4%BD%A0%E8%83%BD%E8%AF%B4%E8%AF%B4Spring%E6%A1%86%E6%9E%B6%E4%B8%ADBean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%90%97%EF%BC%9F/"/>
    <id>https://bj-wutz.github.io/2022/05/02/%E3%80%90Java%E9%9D%A2%E8%AF%95%E7%B2%BE%E9%80%89%E3%80%91%E3%80%9002%E6%9C%9F%E3%80%91%E4%BD%A0%E8%83%BD%E8%AF%B4%E8%AF%B4Spring%E6%A1%86%E6%9E%B6%E4%B8%ADBean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%90%97%EF%BC%9F/</id>
    <published>2022-05-02T02:54:28.000Z</published>
    <updated>2022-05-10T11:09:02.232Z</updated>
    
    <content type="html"><![CDATA[<h2 id="首先简单说一下"><a href="#首先简单说一下" class="headerlink" title="首先简单说一下"></a><strong>首先简单说一下</strong></h2><p>1、实例化一个Bean－－也就是我们常说的new；</p><p>2、按照Spring上下文对实例化的Bean进行配置－－也就是IOC注入；</p><p>3、如果这个Bean已经实现了BeanNameAware接口，会调用它实现的setBeanName(String)方法，此处传递的就是Spring配置文件中Bean的id值</p><p>4、如果这个Bean已经实现了BeanFactoryAware接口，会调用它实现的setBeanFactory(setBeanFactory(BeanFactory)传递的是Spring工厂自身（可以用这个方式来获取其它Bean，只需在Spring配置文件中配置一个普通的Bean就可以）；</p><p>5、如果这个Bean已经实现了ApplicationContextAware接口，会调用setApplicationContext(ApplicationContext)方法，传入Spring上下文（同样这个方式也可以实现步骤4的内容，但比4更好，因为ApplicationContext是BeanFactory的子接口，有更多的实现方法）；</p><p>6、如果这个Bean关联了BeanPostProcessor接口，将会调用postProcessBeforeInitialization(Object obj, String s)方法，BeanPostProcessor经常被用作是Bean内容的更改，并且由于这个是在Bean初始化结束时调用那个的方法，也可以被应用于内存或缓存技术；</p><p>7、如果Bean在Spring配置文件中配置了init-method属性会自动调用其配置的初始化方法。</p><p>8、如果这个Bean关联了BeanPostProcessor接口，将会调用postProcessAfterInitialization(Object obj, String s)方法、；</p><p><strong>注：以上工作完成以后就可以应用这个Bean了，那这个Bean是一个Singleton的，所以一般情况下我们调用同一个id的Bean会是在内容地址相同的实例，当然在Spring配置文件中也可以配置非Singleton，这里我们不做赘述。</strong></p><p>9、当Bean不再需要时，会经过清理阶段，如果Bean实现了DisposableBean这个接口，会调用那个其实现的destroy()方法；</p><p>10、最后，如果这个Bean的Spring配置中配置了destroy-method属性，会自动调用其配置的销毁方法。</p><h2 id="结合代码理解一下"><a href="#结合代码理解一下" class="headerlink" title="结合代码理解一下"></a><strong>结合代码理解一下</strong></h2><h3 id="1、Bean的定义"><a href="#1、Bean的定义" class="headerlink" title="1、Bean的定义"></a><strong>1、Bean的定义</strong></h3><p>Spring通常通过配置文件定义Bean。如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=”1.0″ encoding=”UTF-8″?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">”http://www.springframework.org/schema/beans”</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:xsi</span>=<span class="string">”http://www.w3.org/2001/XMLSchema-instance”</span></span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">”http://www.springframework.org/schema/beans</span> <span class="attr">http:</span>//<span class="attr">www.springframework.org</span>/<span class="attr">schema</span>/<span class="attr">beans</span>/<span class="attr">spring-beans-2.0.xsd</span>”&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">”HelloWorld”</span> <span class="attr">class</span>=<span class="string">”com.pqf.beans.HelloWorld”</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">”msg”</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">value</span>&gt;</span>HelloWorld<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这个配置文件就定义了一个标识为 HelloWorld 的Bean。在一个配置文档中可以定义多个Bean。</p><h3 id="2、Bean的初始化"><a href="#2、Bean的初始化" class="headerlink" title="2、Bean的初始化"></a><strong>2、Bean的初始化</strong></h3><p>有两种方式初始化Bean。</p><p>1、在配置文档中通过指定init-method 属性来完成</p><p>在Bean的类中实现一个初始化Bean属性的方法，如init()，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorld</span>&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">   <span class="keyword">public</span> <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">      msg=”HelloWorld”;</span><br><span class="line">      date = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    …… </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，在配置文件中设置init-mothod属性。</p><p>2、实现 org.springframwork.beans.factory.InitializingBean接口</p><p>Bean实现InitializingBean接口，并且增加 afterPropertiesSet() 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorld</span> implement InitializingBean &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">   <span class="keyword">public</span> <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> &#123;</span><br><span class="line">       msg=<span class="string">&quot;向全世界问好！&quot;</span>;</span><br><span class="line">       date = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">   &#125;</span><br><span class="line">    …… </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么，当这个Bean的所有属性被Spring的BeanFactory设置完后，会自动调用afterPropertiesSet()方法对Bean进行初始化，于是，配置文件就不用指定 init-method属性了。</p><h3 id="3、Bean的调用"><a href="#3、Bean的调用" class="headerlink" title="3、Bean的调用"></a><strong>3、Bean的调用</strong></h3><p>有三种方式可以得到Bean并进行调用：</p><p>1、使用BeanWrapper</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">HelloWorld</span> <span class="variable">hw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HelloWorld</span>();</span><br><span class="line"><span class="type">BeanWrapper</span> <span class="variable">bw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BeanWrapperImpl</span>(hw);</span><br><span class="line">bw.setPropertyvalue(<span class="string">&quot;msg&quot;</span>,<span class="string">&quot;HelloWorld&quot;</span>);</span><br><span class="line">System.out.println(bw.getPropertyCalue(<span class="string">&quot;msg&quot;</span>));</span><br></pre></td></tr></table></figure><p>2、使用BeanFactory</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;config.xml&quot;</span>);</span><br><span class="line"><span class="type">XmlBeanFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XmlBeanFactory</span>(is);</span><br><span class="line"><span class="type">HelloWorld</span> <span class="variable">hw</span> <span class="operator">=</span> (HelloWorld) factory.getBean(<span class="string">&quot;HelloWorld&quot;</span>);</span><br><span class="line">System.out.println(hw.getMsg());</span><br></pre></td></tr></table></figure><p>3、使用ApplicationConttext</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ApplicationContext</span> <span class="variable">actx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FleSystemXmlApplicationContext</span>(<span class="string">&quot;config.xml&quot;</span>);</span><br><span class="line"><span class="type">HelloWorld</span> <span class="variable">hw</span> <span class="operator">=</span> (HelloWorld) actx.getBean(”HelloWorld”);</span><br><span class="line">System.out.println(hw.getMsg());</span><br></pre></td></tr></table></figure><h3 id="4、Bean的销毁"><a href="#4、Bean的销毁" class="headerlink" title="4、Bean的销毁"></a>4、Bean的销毁</h3><p>1、使用配置文件中的 destory-method 属性</p><p>与初始化属性 init-methods类似，在Bean的类中实现一个撤销Bean的方法，然后在配置文件中通过 destory-method指定，那么当bean销毁时，Spring将自动调用指定的销毁方法。</p><p>2、实现 org.springframwork.bean.factory.DisposebleBean接口</p><p>如果实现了DisposebleBean接口，那么Spring将自动调用bean中的Destory方法进行销毁，所以，Bean中必须提供Destory方法。</p><h3 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h3><p><img src="/.%5C%E3%80%90Java%E9%9D%A2%E8%AF%95%E7%B2%BE%E9%80%89%E3%80%91%E3%80%9002%E6%9C%9F%E3%80%91%E4%BD%A0%E8%83%BD%E8%AF%B4%E8%AF%B4Spring%E6%A1%86%E6%9E%B6%E4%B8%ADBean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%90%97%EF%BC%9F%5C1.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;首先简单说一下&quot;&gt;&lt;a href=&quot;#首先简单说一下&quot; class=&quot;headerlink&quot; title=&quot;首先简单说一下&quot;&gt;&lt;/a&gt;&lt;strong&gt;首先简单说一下&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;1、实例化一个Bean－－也就是我们常说的new；&lt;/p&gt;
&lt;p&gt;</summary>
      
    
    
    
    <category term="Java面试精选" scheme="https://bj-wutz.github.io/categories/Java%E9%9D%A2%E8%AF%95%E7%B2%BE%E9%80%89/"/>
    
    
    <category term="Java" scheme="https://bj-wutz.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>【Java面试精选】【01期】Spring，SpringMVC，SpringBoot，SpringCloud有什么区别和联系？</title>
    <link href="https://bj-wutz.github.io/2022/05/01/%E3%80%90Java%E9%9D%A2%E8%AF%95%E7%B2%BE%E9%80%89%E3%80%91%E3%80%9001%E6%9C%9F%E3%80%91Spring%EF%BC%8CSpringMVC%EF%BC%8CSpringBoot%EF%BC%8CSpringCloud%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%E5%92%8C%E8%81%94%E7%B3%BB%EF%BC%9F/"/>
    <id>https://bj-wutz.github.io/2022/05/01/%E3%80%90Java%E9%9D%A2%E8%AF%95%E7%B2%BE%E9%80%89%E3%80%91%E3%80%9001%E6%9C%9F%E3%80%91Spring%EF%BC%8CSpringMVC%EF%BC%8CSpringBoot%EF%BC%8CSpringCloud%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%E5%92%8C%E8%81%94%E7%B3%BB%EF%BC%9F/</id>
    <published>2022-05-01T02:54:19.000Z</published>
    <updated>2022-05-10T11:09:02.258Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a><strong>简单介绍</strong></h2><p>Spring是一个轻量级的控制反转(IoC)和面向切面(AOP)的容器框架。Spring使你能够编写更干净、更可管理、并且更易于测试的代码。</p><p>Spring MVC是Spring的一个模块，一个web框架。通过Dispatcher Servlet, ModelAndView 和 View Resolver，开发web应用变得很容易。主要针对的是网站应用程序或者服务开发——URL路由、Session、模板引擎、静态Web资源等等。</p><p>Spring配置复杂，繁琐，所以推出了Spring boot，约定优于配置，简化了spring的配置流程。</p><p>Spring Cloud构建于Spring Boot之上，是一个关注全局的服务治理框架。</p><h2 id="Spring-VS-SpringMVC："><a href="#Spring-VS-SpringMVC：" class="headerlink" title="Spring VS SpringMVC："></a><strong>Spring VS SpringMVC：</strong></h2><p>Spring是一个一站式的轻量级的java开发框架，核心是控制反转（IOC）和面向切面（AOP），针对于开发的WEB层(springMvc)、业务层(Ioc)、持久层(jdbcTemplate)等都提供了多种配置解决方案；</p><p>SpringMVC是Spring基础之上的一个MVC框架，主要处理web开发的路径映射和视图渲染，属于Spring框架中WEB层开发的一部分；</p><h2 id="SpringMVC-VS-SpringBoot："><a href="#SpringMVC-VS-SpringBoot：" class="headerlink" title="SpringMVC VS SpringBoot："></a><strong>SpringMVC VS SpringBoot：</strong></h2><p>SpringMVC属于一个企业WEB开发的MVC框架，涵盖面包括前端视图开发、文件配置、后台接口逻辑开发等，XML、config等配置相对比较繁琐复杂；</p><p>SpringBoot框架相对于SpringMVC框架来说，更专注于开发微服务后台接口，不开发前端视图；</p><h2 id="SpringBoot和SpringCloud："><a href="#SpringBoot和SpringCloud：" class="headerlink" title="SpringBoot和SpringCloud："></a><strong>SpringBoot和SpringCloud：</strong></h2><p>SpringBoot使用了默认大于配置的理念，集成了快速开发的Spring多个插件，同时自动过滤不需要配置的多余的插件，简化了项目的开发配置流程，一定程度上取消xml配置，是一套快速配置开发的脚手架，能快速开发单个微服务；</p><p>SpringCloud大部分的功能插件都是基于SpringBoot去实现的，SpringCloud关注于全局的微服务整合和管理，将多个SpringBoot单体微服务进行整合以及管理；SpringCloud依赖于SpringBoot开发，而SpringBoot可以独立开发；</p><h2 id="总结下来："><a href="#总结下来：" class="headerlink" title="总结下来："></a><strong>总结下来：</strong></h2><ul><li>Spring是核心，提供了基础功能；</li><li>Spring MVC 是基于Spring的一个 MVC 框架 ；</li><li>Spring Boot 是为简化Spring配置的快速开发整合包；</li><li>Spring Cloud是构建在Spring Boot之上的服务治理框架。</li></ul><p>l Spring是核心，提供了基础功能；</p><p>l Spring MVC 是基于Spring的一个 MVC 框架 ；</p><p>l Spring Boot 是为简化Spring配置的快速开发整合包；</p><p>l Spring Cloud是构建在Spring Boot之上的服务治理框架。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;简单介绍&quot;&gt;&lt;a href=&quot;#简单介绍&quot; class=&quot;headerlink&quot; title=&quot;简单介绍&quot;&gt;&lt;/a&gt;&lt;strong&gt;简单介绍&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;Spring是一个轻量级的控制反转(IoC)和面向切面(AOP)的容器框架。Spring使</summary>
      
    
    
    
    <category term="Java面试精选" scheme="https://bj-wutz.github.io/categories/Java%E9%9D%A2%E8%AF%95%E7%B2%BE%E9%80%89/"/>
    
    
    <category term="Java" scheme="https://bj-wutz.github.io/tags/Java/"/>
    
  </entry>
  
</feed>
